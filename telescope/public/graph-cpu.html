<link rel="import" href="/vendor/polymer/polymer.html">
<dom-module id="cosmos-graph-cpu">
<style>
.container {
    width: 100%;
    min-height: 265px;
    margin: 0;
    padding: 0;
}

.graph {
    min-height: 265px;
    cursor: pointer;
}
</style>
<template>
  <div class="container">
    <div id="graph-cpu"></div>
  </div>
</template>
</dom-module>
<script>
Polymer({
    is: 'cosmos-graph-cpu',
    graphId: 'graph-cpu',
    graphTitle: 'CPU Utilization',
    graphUnit: '%',
    graphPeriod: '10m',
    graphMetricNames: ['StatsCpuTotalUtilization'],
    chart: undefined,
    properties: {
        metrics: {
            type: Array,
            observer: 'metricsChanged'
        }
    },
    ready: function() {
        /*$(this).find('.graph-title').text(this.graphTitle + ' (' + this.graphUnit + ')');
        $(this).find('.graph').attr('id', this.graphId);
        this.drawEmptyGraph('#' + this.graphId, this.graphUnit, this.graphPeriod);*/
    },
    attached: function() {
        // turn on graph runloop
        var chart = c3.generate({
          bindto: this.querySelector('#' + this.graphId),
          data: {
            //x: 'x',
            columns: [
              //['x'],
            ]
          },
          point: { show: false },
          tooltip: { show: true },
          axis: {
            x: { tick: { outer: false } },
            y: { tick: { outer: false } }
          }
        });
        this.chart = chart;
    },
    detached: function() {
        // turn off graph runloop
    },
    makeDefaultDataOptions: function() {
        return {
            label: 'CPU',
            fillColor: 'rgba(72,157,255,0.2)',
            strokeColor: 'rgba(72,157,255,1)',
            pointColor: 'rgba(72,157,255,1)',
            pointStrokeColor: '#fff',
            pointHighlightFill: '#fff',
            pointHighlightStroke: 'rgba(72,157,255,1)'
        };
    },
    metricsChanged: function(newValue, oldValue) {
      // temporary variables
      var statsCpuTotal = this.metrics['StatsCpuTotalUtilization'];

      var columns = [];

      // timeseries
      var timeseries = ['a'];

      // output
      var total = ['CPU'];

      for (var i = statsCpuTotal.length - 1; i >= 0; i--) {
        var stat = statsCpuTotal[i];
        var timestamp = stat[0];
        var value = stat[2];

        timeseries.push(timestamp);
        total.push(value);
      }

      //columns.push(timeseries);
      columns.push(total);

      this.chart.load({
        columns: columns,
        types: {
          CPU: 'area'
        }
      });

      return;
        var self = this;
        var defaultDataOptions = this.makeDefaultDataOptions();
        var times = this.getTimeList();
        var datasets = this.getDataSets();

        var charts = [{
            dataOptions: defaultDataOptions,
            datasets: datasets[0]
        }];

        this.drawGraph('#' + this.graphId, undefined, 260, times, charts, this.graphUnit, {
            customTooltips: function(tooltip) {
                var tooltipEl = $('#chartjs-tooltip');
                if (!tooltip) {
                    tooltipEl.remove();
                    return;
                }

                if (tooltipEl.size() == 0) {
                    tooltipEl = $('<div id="chartjs-tooltip"></div>');
                    $('body').append(tooltipEl);
                }

                var innerHtml = '';
                innerHtml += [
                    '<div class="chartjs-tooltip-section">',
                    '       <span class="chartjs-tooltip-key" style="background-color:' + self.makeDefaultDataOptions().strokeColor + '"></span>',
                    '       <span class="chartjs-tooltip-value">' + tooltip.text + '</span>',
                    '</div>'
                ].join('');


                tooltipEl.html(innerHtml);
                var offset = $(tooltip.chart.canvas).offset();
                tooltipEl.css({
                    'left': offset.left + tooltip.x + 'px',
                    'top': offset.top + tooltip.y + 'px',
                    'fontFamily': tooltip.fontFamily,
                    'fontSize': tooltip.fontSize,
                    'fontStyle': tooltip.fontStyle
                });
            }
        });
    },
    getTimeList: function() {
        var times = [];
        var metric = this.metrics[this.graphMetricNames[0]];
        for (var i = metric.length - 1; i >= 0; i--) {
            times.push(metric[i][0] * 1000);
        }
        return times;
    },
    getDataSets: function() {
        var datasets = [];
        for (var i = 0; i < this.graphMetricNames.length; i++) {
            datasets.push([]);
            var metric = this.graphMetricNames[i];
            var dataset = this.metrics[metric];
            for (var j = dataset.length - 1; j >= 0; j--) {
                var data = dataset[j];
                datasets[i].push(data[2]);
            }
        }
        return datasets;
    },
    setContainer: function(container) {
        // remove planet, container graph runloop
        // set container graph runloop
    },
    drawEmptyGraph: function(selector, unit, period) {
        var self = this;
        var width = undefined;
        var height = 265;
        var times = [],
            values = [],
            points = 10,
            timeWidth = 60 * 1000;

        if (period == '10m') points = 10;
        else if (period == '30m') points = 30;
        else if (period == '3h') {
            points = 36;
            timeWidth *= 5;
        } else if (period == '8h') {
            points = 32;
            timeWidth *= 15;
        } else if (period == '24h') {
            points = 24;
            timeWidth *= 60;
        }

        var now = (new Date()).getTime();
        for (var i = points; i > 0; i--) {
            times.push(now - (i * timeWidth));
            values.push(0);
        }

        setTimeout(function() {
            self.drawGraph(selector, width, height, times, [{
                datasets: values
            }], unit);
        }, 10);
    },
    drawGraph: function(selector, width, height, times, charts, unit, option) {
        var dataset = {
            labels: [],
            datasets: []
        };

        // labels
        if (times) {
            dataset.labels = function() {
                var labels = [];
                for (var i = 0; i < times.length; i++) {
                    labels.push(moment(times[i]).format('HH:mm'));
                }
                return labels;
            }();
        }

        // charts
        for (var i = 0; i < charts.length; i++) {
            var chart = charts[i];
            var options = chart.dataOptions;
            var datasets = chart.datasets;

            if (!options) {
                options = {};
            }
            var chartData = $.extend({}, options);
            chartData.data = chart.datasets;
            dataset.datasets[i] = chartData;
        }

        // dom
        var container = $('<div>');
        var chart = $('<canvas>').attr('height', height);
        if (!isNaN(width)) chart.attr('width', width);

        // option
        option = option || {};
        option.bezierCurve = false;
        option.pointHitDetectionRadius = 4;
        option.scaleLabel = "<%=' ' + value%>";
        option.scaleFontSize = 12;
        option.scaleFontColor = '#888';
        option.tooltipTemplate = "[<%=time%>] <%=value%>" + unit;
        option.showTooltips = true;
        option.scaleIntegersOnly = false;
        option.responsive = true;
        option.maintainAspectRatio = false;
        option.pointDot = false;
        option.animation = false;

        // redraw
        container.append(chart);
        $(selector).empty().append(container);
        var context = chart[0].getContext('2d');
        var chart = new Chart(context).Line(dataset, option);

        // points
        var points = chart.datasets[0].points;
        for (var i = 0; i < points.length; i++) {
            points[i].time = moment(times[i]).format('YYYY-MM-DD HH:mm');
        }

        return chart;
    }
});
</script>
