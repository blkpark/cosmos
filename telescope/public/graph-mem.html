<link rel="import" href="/vendor/polymer/polymer.html">
<dom-module id="cosmos-graph-mem">
    <style>
    .container {
        width: 100%;
        min-height: 265px;
        margin: 0;
        padding: 0;
    }
    
    .graph-title {
        margin: 0;
        padding-bottom: 10px;
        font-size: 17px;
        text-align: center;
    }
    
    .graph {
        min-height: 265px;
        cursor: pointer;
    }
    </style>
    <template>
        <div class="container">
            <h3 class="graph-title"></h3>
            <div class="graph"></div>
        </div>
    </template>
</dom-module>
<script>
Polymer({
    is: 'cosmos-graph-mem',

    graphId: 'graph-mem',
    graphTitle: 'Memory Usage',
    graphUnit: 'MB',
    graphPeriod: '10m',
    graphMetricNames: ['StatsMemoryUsage', 'StatsMemoryLimit'],
    properties: {
        metrics: {
            type: Array,
            observer: 'metricsChanged'
        }
    },

    ready: function() {
        $(this).find('.graph-title').text(this.graphTitle + ' (' + this.graphUnit + ')');
        $(this).find('.graph').attr('id', this.graphId);
        this.drawEmptyGraph('#' + this.graphId, this.graphUnit, this.graphPeriod);
    },
    attached: function() {
        // turn on graph runloop
    },
    detached: function() {
        // turn off graph runloop
    },
    makeDefaultDataOptions: function() {
        return {
            label: 'Metrics',
            fillColor: 'rgba(72,157,255,0.2)',
            strokeColor: 'rgba(72,157,255,1)',
            pointColor: 'rgba(72,157,255,1)',
            pointStrokeColor: '#fff',
            pointHighlightFill: '#fff',
            pointHighlightStroke: 'rgba(72,157,255,1)'
        };
    },
    metricsChanged: function(newValue, oldValue) {
        var dataOptionsForUsageMem = this.makeDefaultDataOptions();
        var dataOptionsForFreeMem = this.makeDefaultDataOptions();

        var times = this.getTimeList();
        var datasets = this.getDataSets();
        this.convertLimitMemToFreeMem(datasets);

        dataOptionsForFreeMem.pointColor = "rgba(102,102,255,1)";
        dataOptionsForFreeMem.strokeColor = "rgba(102,102,255,1)";
        dataOptionsForFreeMem.fillColor = "rgba(102,102,255,0.2)";

        var charts = [{
            dataOptions: dataOptionsForUsageMem,
            datasets: datasets[0]
        }, {
            dataOptions: dataOptionsForFreeMem,
            datasets: datasets[1]
        }];

        this.drawGraph('#' + this.graphId, undefined, 260, times, charts, this.graphUnit, {
            customTooltips: function(tooltip) {
                var tooltipEl = $('#chartjs-tooltip');
                if (!tooltip) {
                    tooltipEl.remove();
                    return;
                }

                if (tooltipEl.size() == 0) {
                    tooltipEl = $('<div id="chartjs-tooltip"></div>');
                    $('body').append(tooltipEl);
                }
                console.log(tooltip);
                var innerHtml = '';
                for (var i = 0; i < tooltip.labels.length; i++) {
                    var label;
                    if (i == 0) {
                        // Usage
                        label = "Usage: ";
                    } else if (i == 1) {
                        // Free
                        label = "Free: "
                    }
                    
                    innerHtml += [
                        '<div class="chartjs-tooltip-section">',
                        '       <span class="chartjs-tooltip-key" style="background-color:' + tooltip.legendColors[i].fill + '"></span>',
                        '       <span class="chartjs-tooltip-value">' + label + tooltip.labels[i] + 'MB</span>',
                        '</div>'
                    ].join('');
                }

                tooltipEl.html(innerHtml);
                var offset = $(tooltip.chart.canvas).offset();
                tooltipEl.css({
                    'left': offset.left + tooltip.x + 'px',
                    'top': offset.top + tooltip.y + 'px',
                    'fontFamily': tooltip.fontFamily,
                    'fontSize': tooltip.fontSize,
                    'fontStyle': tooltip.fontStyle
                });
            }
        });
    },
    convertLimitMemToFreeMem: function(datasets) {
        // 0 -> Usage
        // 1 -> Limit
        for (var i = 0; i < datasets[0].length; i++) {
            datasets[1][i] -= datasets[0][i];
        }
    },
    getTimeList: function() {
        var times = [];
        var metric = this.metrics[this.graphMetricNames[0]];
        for (var i = metric.length - 1; i >= 0; i--) {
            times.push(metric[i][0] * 1000);
        }
        return times;
    },
    getDataSets: function() {
        var datasets = [];
        var MB = 1024 * 1024;
        for (var i = 0; i < this.graphMetricNames.length; i++) {
            datasets.push([]);
            var metric = this.graphMetricNames[i];
            var dataset = this.metrics[metric];
            for (var j = dataset.length - 1; j >= 0; j--) {
                var data = dataset[j];
                datasets[i].push(parseInt(data[2] / MB));
            }
        }
        return datasets;
    },
    setContainer: function(container) {
        // remove planet, container graph runloop
        // set container graph runloop
    },
    drawEmptyGraph: function(selector, unit, period) {
        var self = this;
        var width = undefined;
        var height = 265;
        var times = [],
            values = [],
            points = 10,
            timeWidth = 60 * 1000;

        if (period == '10m') points = 10;
        else if (period == '30m') points = 30;
        else if (period == '3h') {
            points = 36;
            timeWidth *= 5;
        } else if (period == '8h') {
            points = 32;
            timeWidth *= 15;
        } else if (period == '24h') {
            points = 24;
            timeWidth *= 60;
        }

        var now = (new Date()).getTime();
        for (var i = points; i > 0; i--) {
            times.push(now - (i * timeWidth));
            values.push(0);
        }

        setTimeout(function() {
            self.drawGraph(selector, width, height, times, [{
                datasets: values
            }], unit);
        }, 10);
    },
    drawGraph: function(selector, width, height, times, charts, unit, option) {
        var dataset = {
            labels: [],
            datasets: []
        };

        // labels
        if (times) {
            dataset.labels = function() {
                var labels = [];
                for (var i = 0; i < times.length; i++) {
                    labels.push(moment(times[i]).format('HH:mm'));
                }
                return labels;
            }();
        }

        // charts
        for (var i = 0; i < charts.length; i++) {
            var chart = charts[i];
            var options = chart.dataOptions;
            var datasets = chart.datasets;

            if (!options) {
                options = {};
            }
            var chartData = $.extend({}, options);
            chartData.data = chart.datasets;
            dataset.datasets[i] = chartData;
        }

        // dom
        var container = $('<div>');
        var chart = $('<canvas>').attr('height', height);
        if (!isNaN(width)) chart.attr('width', width);

        // option
        option = option || {};
        option.bezierCurve = false;
        option.pointHitDetectionRadius = 4;
        option.scaleLabel = "<%=' ' + value%>";
        option.scaleFontSize = 12;
        option.scaleFontColor = '#888';
        option.tooltipTemplate = "[<%=time%>] <%=value%>" + unit;
        option.showTooltips = true;
        option.scaleIntegersOnly = false;
        option.responsive = true;
        option.maintainAspectRatio = false;

        // redraw
        container.append(chart);
        $(selector).empty().append(container);
        var context = chart[0].getContext('2d');
        var chart = new Chart(context).Line(dataset, option);

        // points
        for (var j = 0; j < chart.datasets.length - 1; j++) {
            var points = chart.datasets[j].points;
            for (var i = 0; i < points.length; i++) {
                points[i].time = moment(times[i]).format('YYYY-MM-DD HH:mm');
            }
        }

        return chart;
    }
});
</script>
