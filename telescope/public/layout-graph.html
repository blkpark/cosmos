<link rel="import" href="/vendor/polymer/polymer.html">
<script src="/vendor/moment/moment.js"></script>

<dom-module id="cosmos-layout-graph">
<style>
.container {
  width: 100%;
  min-height: 265px;
  margin: 0;
  padding: 0;
}

.graph-title {
  margin: 0;
  padding: 0;
  font-size: 17px;
  text-align: center;
}

.graph {
  min-height: 265px;
  cursor: pointer;
}
</style>
<template>
  <div class="container">
    <h3 class="graph-title">{{graphTitle}}</h3>
    <div class="graph"></div>
  </div>
</template>
</dom-module>
<script>
Polymer({
  is: 'cosmos-layout-graph',
  properties: {
    graphId: {
      type: String,
      value: ''
    },
    graphTitle: {
      type: String,
      value: ''
    },
    graphUnit: {
      type: String,
      value: ''
    },
    graphMarginTop: {
      type: String,
      value: '60px'
    },
    cosmosMetricIds: {
      type: Array,
      value: []
    }
  },
  ready: function() {
    this.cosmosMetricIds = this.getCosmosMetricIds(this.graphId);

    var selector = '#graph-' + this.graphId;
    var unit = this.graphUnit;
    var period = '10m';

    $(this).find('h3').css('padding-top', this.graphMarginTop).css('padding-bottom', '10px');
    $(this).find('.graph').attr('id', 'graph-' + this.graphId);
    this.drawEmptyGraph(selector, unit, period);
  },
  attached: function() {
    // turn on graph runloop
  },
  detached: function() {
    // turn off graph runloop
  },
  getCosmosMetricIds: function(graphId) {
    var cosmosMetricIds = undefined;
    switch (this.graphId) {
      case 'cpu':
        cosmosMetricIds = ['StatsCpuTotalUtilization'];
        break;
      case 'memory':
        cosmosMetricIds = ['StatsMemoryUsage', 'StatsMemoryLimit']; // ordered
        break;
      case 'network-in':
        cosmosMetricIds = ['StatsNetworkRxBytes'];
        break;
      case 'network-out':
        cosmosMetricIds = ['StatsNetworkTxBytes'];
        break;
      default:
        cosmosMetricIds = [];
        break;
    }
    return cosmosMetricIds;
  },
  getPlanetCharts: function(res, callback) {
    // temp variables
    var container = undefined;
    var metric = undefined;
    var time = undefined;
    var value = undefined;
    var containerLength = undefined;
    var metricLength = undefined;
    var metricId = undefined;
    //var chart = undefined;
    var division = 1;
    if (this.graphUnit == 'KB') { division = 1024; }
    else if (this.graphUnit == 'MB') { division = 1024 * 1024; }

    // output
    var charts = [];
    var times = [];

    // charts loop
    for (var i = 0; i < this.cosmosMetricIds.length; i++) {
      var values = [];
      metricId = this.cosmosMetricIds[i];

      // containers loop
      for (var j = 0, containerLength = res.length; j < containerLength; j++) {
        container = res[j];
        metric = container[metricId];

        // time + metric tuple loop
        for (var k = metric.length - 1, metricLength = metric.length - 1; k >= 0; k--) {
          time = metric[k][0] * 1000; // timestamp
          value = metric[k][2] / division; // value
          times[metricLength - k] = time;
          // x3 = x1 + x2
          values[metricLength - k] = (values[metricLength - k] ? values[metricLength - k] : 0) + value;
        }

      }

      var chart = {values: values};
      charts[i] = chart;
    }

    callback(times, charts);
  },
  setPlanet: function(planet) {
    // remove planet, container graph runloop
    // set planet graph runloop
    var self = this;
    var selector = '#graph-' + this.graphId;
    var width = undefined;
    var height = 265;
    var unit = this.graphUnit;

    Cosmos.getContainersOfPlanet(planet, function(res){
      self.getPlanetCharts(res, function(times, charts){
        // for free memory
        if (self.graphId == 'memory') {
          for (var i = 0; i < charts[1].values.length; i++) { // ordered, check getCosmosMetricIds()
            charts[1].values[i] = charts[1].values[i] - charts[0].values[i];
          }
        }

        setTimeout(function() {
          self.drawGraph(selector, width, height, times, charts, unit);
        }, 10);
      });
    }, function(jqXHR){
      var notification = {
        type: 'error',
        message: 'Cosmos server did not respond any response.'
      };
      $('cosmos-layout-header').trigger('cosmos-notification', notification);
    });
  },
  setContainer: function(container) {
    // remove planet, container graph runloop
    // set container graph runloop
  },
  drawEmptyGraph: function(selector, unit, period) {
    var self = this;
    var width = undefined;
    var height = 265;
    var times = [],
        values = [],
        points = 10,
        timeWidth = 60 * 1000;

    if (period == '10m') points = 10;
    else if (period == '30m') points = 30;
    else if (period == '3h') { points = 36; timeWidth *= 5; }
    else if (period == '8h') { points = 32; timeWidth *= 15; }
    else if (period == '24h') { points = 24; timeWidth *= 60; }

    var now = (new Date()).getTime();
    for (var i = points; i > 0; i--) {
      times.push(now - (i * timeWidth));
      values.push(0);
    }

    setTimeout(function() {
      self.drawGraph(selector, width, height, times, [{ values: values }], unit);
    }, 10);
  },
  drawGraph: function(selector, width, height, times, charts, unit, option) {
    var dataset = {
      labels: [],
      datasets: []
    };

    // labels
    if (times) {
      dataset.labels = function() {
        var labels = [];
        for (var i = 0; i < times.length; i++) {
          labels.push(moment(times[i]).format('HH:mm'));
        }
        return labels;
      }();
    }

    // charts
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];

      chart.options = {
        label: 'Metrics',
        fillColor: 'rgba(72,157,255,0.2)',
        strokeColor: 'rgba(72,157,255,1)',
        pointColor: 'rgba(72,157,255,1)',
        pointStrokeColor: '#fff',
        pointHighlightFill: '#fff',
        pointHighlightStroke: 'rgba(72,157,255,1)',
        data: chart.values
      };

      dataset.datasets[i] = chart.options;
    }

    // dom
    var container = $('<div>');
    var chart = $('<canvas>').attr('height', height);
    if (!isNaN(width)) chart.attr('width', width);

    // option
    option = option || {};
    option.bezierCurve = false;
    option.pointHitDetectionRadius = 4;
    option.scaleLabel = "<%=' ' + value%>";
    option.scaleFontSize = 12;
    option.scaleFontColor = '#888';
    option.tooltipTemplate = "[<%=time%>] <%=value%>" + unit;
    option.showTooltips = true;
    option.scaleIntegersOnly = false;
    option.responsive = true;
    option.maintainAspectRatio = false;

    // redraw
    container.append(chart);
    $(selector).empty().append(container);
    var context = chart[0].getContext('2d');
    var chart = new Chart(context).Line(dataset, option);

    // points
    var points = chart.datasets[0].points;
    for (var i = 0; i < points.length; i++) {
      points[i].time = moment(times[i]).format('YYYY-MM-DD HH:mm');
    }

    return chart;
  }
});
</script>
