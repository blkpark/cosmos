<link rel="import" href="/vendor/polymer/polymer.html">
<dom-module id="cosmos-layout-graph">
<style>
.container {
  width: 100%;
  min-height: 265px;
  margin: 0;
  padding: 0;
}

.graph-title {
  margin: 0;
  padding: 0;
  font-size: 17px;
  text-align: center;
}

.graph {
  min-height: 265px;
  cursor: pointer;
}
</style>
<template>
  <div class="container">
    <h3 class="graph-title">{{graphTitle}}</h3>
    <div class="graph"></div>
  </div>
</template>
</dom-module>
<script>
Polymer({
  is: 'cosmos-layout-graph',
  properties: {
    graphId: {
      type: String,
      value: ''
    },
    graphTitle: {
      type: String,
      value: ''
    },
    graphUnit: {
      type: String,
      value: ''
    },
    graphMarginTop: {
      type: String,
      value: '60px'
    },
    cosmosMetricId: {
      type: String,
      value: ''
    }
  },
  ready: function() {
    this.cosmosMetricId = this.getCosmosMetricId(this.graphId);

    var selector = '#graph-' + this.graphId;
    var unit = this.graphUnit;
    var period = '10m';

    $(this).find('h3').css('padding-top', this.graphMarginTop).css('padding-bottom', '10px');
    $(this).find('.graph').attr('id', 'graph-' + this.graphId);
    this.drawEmptyGraph(selector, unit, period);
  },
  attached: function() {
    // turn on graph runloop
  },
  detached: function() {
    // turn off graph runloop
  },
  getCosmosMetricId: function(graphId) {
    var cosmosMetricId = undefined;
    switch (this.graphId) {
      case 'cpu':
        cosmosMetricId = 'StatsCpuTotalUtilization';
        break;
      case 'memory':
        cosmosMetricId = 'StatsMemoryUsage';
        break;
      case 'network-in':
        cosmosMetricId = 'StatsNetworkRxBytes';
        break;
      case 'network-out':
        cosmosMetricId = 'StatsNetworkTxBytes';
        break;
      default:
        cosmosMetricId = '';
        break;
    }
    return cosmosMetricId;
  },
  setPlanet: function(planet) {
    // remove planet, container graph runloop
    // set planet graph runloop
    var self = this;
    var selector = '#graph-' + this.graphId;
    var width = undefined;
    var height = 265;
    var times = null;
    var data = null;
    var unit = this.graphUnit;

    Cosmos.getContainersOfPlanet(planet, function(res){
      var container = undefined;
      var metric = undefined;
      var time = undefined;
      var value = undefined;
      var containerLength = undefined;
      var metricLength = undefined;

      var timeset = [];
      var dataset = [];

      var division = 1;
      if (self.graphUnit == 'KB') { division = 1024; }
      else if (self.graphUnit == 'MB') { division = 1024 * 1024; }

      // containers loop
      for (var i = 0, containerLength = res.length; i < containerLength; i++) {
        container = res[i];
        metric = container[self.cosmosMetricId];

        // time + metric tuple loop
        for (var j = metric.length - 1, metricLength = metric.length - 1; j >= 0; j--) {
          time = metric[j][0] * 1000; // timestamp
          value = metric[j][2] / division; // value
          timeset[metricLength - j] = time;
          dataset[metricLength - j] = (dataset[j] ? dataset[j] : 0) + value;
        }

      }

      self.drawGraph(selector, width, height, timeset, dataset, unit);
    }, function(jqXHR){
      var notification = {
        type: 'error',
        message: "Cosmos server didn't respond any response."
      };
      $('cosmos-layout-header').trigger('cosmos-notification', notification);
    });
  },
  setContainer: function(container) {
    // remove planet, container graph runloop
    // set container graph runloop
  },
  drawEmptyGraph: function(selector, unit, period) {
    var self = this;
    var data = [],
        times = [],
        points = 10,
        timeWidth = 60 * 1000;

    if (period == '10m') {
        points = 10;
    } else if (period == '30m') {
        points = 30;
    } else if (period == '3h') {
        points = 36;
        timeWidth *= 5;
    } else if (period == '8h') {
        points = 32;
        timeWidth *= 15;
    } else if (period == '24h') {
        points = 24;
        timeWidth *= 60;
    }

    var now = (new Date()).getTime();
    for (var i = points; i > 0; i--) {
      data.push(0);
      times.push(now - (i * timeWidth));
    }

    var height = 265;

    setTimeout(function() {
      self.drawGraph(selector, undefined, height, times, data, unit);
    }, 10);
  },
  drawGraph: function(selector, width, height, times, data, unit, scaleOpt) {
    var dataset = {
      labels: [],
      datasets: [{
        label: 'Metrics',
        fillColor: 'rgba(72,157,255,0.2)',
        strokeColor: 'rgba(72,157,255,1)',
        pointColor: 'rgba(72,157,255,1)',
        pointStrokeColor: '#fff',
        pointHighlightFill: '#fff',
        pointHighlightStroke: 'rgba(72,157,255,1)',
        data: []
      }]
    };
    if (times) {
      dataset.labels = function() {
        var labels = [];
        for (var i = 0; i < times.length; i++) {
          labels.push(moment(times[i]).format('HH:mm'));
        }
        return labels;
      }();
    }
    if (data) {
      dataset.datasets[0].data = data;
    }
    var container = $('<div/>').css({
      'text-align': 'center'
    });
    var chart = $('<canvas/>').css({
      'display': 'inline-block'
    }).attr('height', height);
    var opt = {
      bezierCurve: false,
      pointHitDetectionRadius: 4,
      scaleLabel: "<%=' ' + value%>",
      scaleFontSize: 12,
      scaleFontColor: '#888',
      tooltipTemplate: "[<%=time%>] <%=value%>" + unit,
      showTooltips: true,
      scaleIntegersOnly: false
    };
    if (scaleOpt) {
      var keys = Object.keys(scaleOpt);
      for (var i in keys) {
        opt[keys[i]] = scaleOpt[keys[i]];
      }
    }

    if (isNaN(width)) {
      opt.responsive = true;
      opt.maintainAspectRatio = false;
    } else {
      chart.attr('width', width);
    }

    container.append(chart);
    $(selector).empty().append(container);

    var ctx = chart[0].getContext('2d');
    var chart = new Chart(ctx).Line(dataset, opt);

    var points = chart.datasets[0].points;
    for (var i = 0; i < points.length; i++) {
      points[i].time = moment(times[i]).format('YYYY-MM-DD HH:mm');
    }
    return chart;
  }
});
</script>
